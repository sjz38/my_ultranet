# ==============================================================
# Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC v2019.2.1 (64-bit)
# Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
# ==============================================================
package require math::bignum
set SupportDataType 0

proc glob-r {{dir .}} {
    # {{{
    set res {}
    foreach i [lsort [glob -nocomplain -dir $dir *]] {
        if {[file type $i]=="directory"} {
            eval lappend  res [glob-r $i]
        } else {
            lappend res $i
        }
    }
    set res
    # }}}
}


proc sort_file_names {files {top_name {}}} {
    if { [llength $files] < 2 } {
        return $files
    }
    set files [lsort -dictionary $files]
    if { $top_name eq "" } {
        return $files
    }
    set top_file ""
    set res {}
    foreach f $files {
        if { [file tail $f] eq $top_name } {
            if { $top_file ne "" } {
                error "Found multiple $top_name files"
            }
            set top_file $f
        } else {
            lappend res $f
        }
    }
    if { $top_file ne "" } {
        lappend res $top_file
    }
    return $res
}
    

## IP Info
set Vendor      "xilinx.com"
set Library     "hls"
set IPName      "test"
set Version     "1.0"
set DisplayName "Test"
set Revision    "2112805781"
set Description "An IP generated by Vivado HLS"
set Device      "zynquplus"
set AutoFamily  ""
set Taxonomy    "/VIVADO_HLS_IP"
set target_part "xczu3eg-sbva484-1-i"
set target_lang "verilog"
set has_xpm_memory "0"
set sdx_kernel_name "test"
set sdx_kernel_type ""
set sdx_kernel_files {}
set enable_xo_gen 0
set sdaccel_dir [file join [pwd] .. kernel]
set solution_dir "/work/shared/users/meng/sjz38/tmp/my_ultranet/hls_projects/main-deploy/out_dataflow.prj/solution1"
set debug_dir [file join $solution_dir .debug]
set xo_hls_files_dir ""
set hdl_module_list {test_fpext_32ns_6UhA
test_srem_10ns_10VhK
test_srem_9ns_9nsWhU
test_mux_32_8_1_1
test_mul_mul_20nsXh4
conv113_weight_cobkb
conv113_weight_cocud
conv113_weight_codEe
conv113_weight_coeOg
conv113_weight_cofYi
conv113_weight_cog8j
conv113_weight_cohbi
conv113_weight_coibs
conv113_weight_cojbC
conv113_weight_cokbM
conv113_weight_colbW
conv113_weight_comb6
conv113_weight_concg
conv113_weight_coocq
conv113_weight_copcA
conv113_weight_coqcK
conv113_weight_corcU
conv113_weight_cosc4
conv113_weight_cotde
conv113_weight_coudo
conv113_weight_covdy
conv113_weight_cowdI
conv113_weight_coxdS
conv113_weight_coyd2
conv113_weight_cozec
conv113_weight_coAem
conv113_weight_coBew
conv113_conv1_linCeG
conv113_conv1_linKfY
conv113_conv1_winLf8
conv113_conv1_winMgi
test_mac_muladd_10iy
relu_bn1_a_batchnYie
relu_bn1_b_batchnZio
maxpool1_pool1_li1iI
test_mux_164_5_1_1
test_mac_muladd_5ehP
test_mac_muladd_5eiP
test_mac_muladd_5ejP
test_mac_muladd_5ekP
test_mac_muladd_5elP
test_mac_muladd_5emP
test_mac_muladd_5enQ
test_mac_muladd_5eoQ
test_mac_muladd_5epQ
test_mac_muladd_3eqQ
test_mac_muladd_3erQ
test_mac_muladd_4esQ
test_mac_muladd_4etR
conv2_weight_conv2iS
conv2_weight_conv3i2
conv2_weight_conv4jc
conv2_weight_conv5jm
conv2_weight_conv6jw
conv2_weight_conv7jG
conv2_weight_conv8jQ
conv2_weight_conv9j0
conv2_weight_convbak
conv2_weight_convbbk
conv2_weight_convbck
conv2_weight_convbdk
conv2_weight_convbek
conv2_weight_convbfk
conv2_weight_convbgk
conv2_weight_convbhl
conv2_weight_convbil
conv2_weight_convbjl
conv2_weight_convbkl
conv2_weight_convbll
conv2_weight_convbml
conv2_weight_convbnm
conv2_weight_convbom
conv2_weight_convbpm
conv2_weight_convbqm
conv2_weight_convbrm
conv2_weight_convbsm
conv2_weight_convbtn
conv2_weight_convbun
conv2_weight_convbvn
conv2_weight_convbwn
conv2_weight_convbxn
conv2_weight_convbyn
conv2_weight_convbzo
conv2_weight_convbAo
conv2_weight_convbBo
conv2_weight_convbCo
conv2_weight_convbDo
conv2_weight_convbEo
conv2_weight_convbFp
conv2_weight_convbGp
conv2_weight_convbHp
conv2_weight_convbIp
conv2_weight_convbJp
conv2_weight_convbKp
conv2_weight_convbLp
conv2_weight_convbMq
conv2_weight_convbNq
conv2_weight_convbOq
conv2_weight_convbPq
conv2_weight_convbQq
conv2_weight_convbRq
conv2_weight_convbSr
conv2_weight_convbTr
conv2_weight_convbUr
conv2_weight_convbVr
conv2_weight_convbWr
conv2_weight_convbXr
conv2_weight_convbYs
conv2_weight_convbZs
conv2_weight_convb0s
conv2_weight_convb1s
conv2_weight_convb2s
conv2_weight_convb3s
conv2_weight_convb4t
conv2_weight_convb5t
conv2_weight_convb6t
conv2_weight_convb7t
conv2_weight_convb8t
conv2_weight_convb9t
conv2_weight_convcau
conv2_weight_convcbu
conv2_weight_convccu
conv2_weight_convcdu
conv2_weight_convceu
conv2_weight_convcfu
conv2_weight_convcgu
conv2_weight_convchv
conv2_weight_convciv
conv2_weight_convcjv
conv2_weight_convckv
conv2_weight_convclv
conv2_weight_convcmv
conv2_weight_convcnw
conv2_weight_convcow
conv2_weight_convcpw
conv2_weight_convcqw
conv2_weight_convcrw
conv2_weight_convcsw
conv2_weight_convctx
conv2_weight_convcux
conv2_weight_convcvx
conv2_weight_convcwx
conv2_weight_convcxx
conv2_weight_convcyx
conv2_weight_convczy
conv2_weight_convcAy
conv2_weight_convcBy
conv2_weight_convcCy
conv2_weight_convcDy
conv2_weight_convcEy
conv2_weight_convcFz
conv2_weight_convcGz
conv2_weight_convcHz
conv2_weight_convcIz
conv2_weight_convcJz
conv2_weight_convcKz
conv2_weight_convcLz
conv2_weight_convcMA
conv2_weight_convcNA
conv2_weight_convcOA
conv2_weight_convcPA
conv2_weight_convcQA
conv2_weight_convcRA
conv2_weight_convcSB
conv2_weight_convcTB
conv2_weight_convcUB
conv2_weight_convcVB
conv2_weight_convcWB
conv2_weight_convcXB
conv2_weight_convcYC
conv2_weight_convcZC
conv2_weight_convc0C
conv2_weight_convc1C
conv2_weight_convc2C
conv2_weight_convc3C
conv2_weight_convc4D
conv2_weight_convc5D
conv2_weight_convc6D
conv2_weight_convc7D
conv2_weight_convc8D
conv2_weight_convc9D
conv2_weight_convdaE
conv2_weight_convdbE
conv2_weight_convdcE
conv2_weight_convddE
conv2_weight_convdeE
conv2_weight_convdfE
conv2_weight_convdgE
conv2_weight_convdhF
conv2_weight_convdiF
conv2_weight_convdjF
conv2_weight_convdkF
conv2_weight_convdlF
conv2_conv2_line_dmF
conv2_conv2_line_d7N
conv2_conv2_windod8N
conv2_conv2_windod9N
test_mac_muladd_1ewR
relu_bn2_a_batchneuR
relu_bn2_b_batchnevR
test_mux_325_5_1_1
test_mac_muladd_5kTb
test_mac_muladd_5kUb
test_mac_muladd_3kVb
conv3_weight_conveyR
conv3_weight_convezS
conv3_weight_conveAS
conv3_weight_conveBS
conv3_weight_conveCS
conv3_weight_conveDS
conv3_weight_conveES
conv3_weight_conveFT
conv3_weight_conveGT
conv3_weight_conveHT
conv3_weight_conveIT
conv3_weight_conveJT
conv3_weight_conveKT
conv3_weight_conveLT
conv3_weight_conveMU
conv3_weight_conveNU
conv3_weight_conveOU
conv3_weight_convePU
conv3_weight_conveQU
conv3_weight_conveRU
conv3_weight_conveSV
conv3_weight_conveTV
conv3_weight_conveUV
conv3_weight_conveVV
conv3_weight_conveWV
conv3_weight_conveXV
conv3_weight_conveYW
conv3_weight_conveZW
conv3_weight_conve0W
conv3_weight_conve1W
conv3_weight_conve2W
conv3_weight_conve3W
conv3_weight_conve4X
conv3_weight_conve5X
conv3_weight_conve6X
conv3_weight_conve7X
conv3_weight_conve8X
conv3_weight_conve9X
conv3_weight_convfaY
conv3_weight_convfbY
conv3_weight_convfcY
conv3_weight_convfdY
conv3_weight_convfeY
conv3_weight_convffY
conv3_weight_convfgY
conv3_weight_convfhZ
conv3_weight_convfiZ
conv3_weight_convfjZ
conv3_weight_convfkZ
conv3_weight_convflZ
conv3_weight_convfmZ
conv3_weight_convfn0
conv3_weight_convfo0
conv3_weight_convfp0
conv3_weight_convfq0
conv3_weight_convfr0
conv3_weight_convfs0
conv3_weight_convft1
conv3_weight_convfu1
conv3_weight_convfv1
conv3_weight_convfw1
conv3_weight_convfx1
conv3_weight_convfy1
conv3_weight_convfz2
conv3_weight_convfA2
conv3_weight_convfB2
conv3_weight_convfC2
conv3_weight_convfD2
conv3_weight_convfE2
conv3_weight_convfF3
conv3_weight_convfG3
conv3_weight_convfH3
conv3_weight_convfI3
conv3_weight_convfJ3
conv3_weight_convfK3
conv3_weight_convfL3
conv3_weight_convfM4
conv3_weight_convfN4
conv3_weight_convfO4
conv3_weight_convfP4
conv3_weight_convfQ4
conv3_weight_convfR4
conv3_weight_convfS5
conv3_weight_convfT5
conv3_weight_convfU5
conv3_weight_convfV5
conv3_weight_convfW5
conv3_weight_convfX5
conv3_weight_convfY6
conv3_weight_convfZ6
conv3_weight_convf06
conv3_weight_convf16
conv3_weight_convf26
conv3_weight_convf36
conv3_weight_convf47
conv3_weight_convf57
conv3_weight_convf67
conv3_weight_convf77
conv3_weight_convf87
conv3_weight_convf97
conv3_weight_convga8
conv3_weight_convgb8
conv3_weight_convgc8
conv3_weight_convgd8
conv3_weight_convge8
conv3_weight_convgf8
conv3_weight_convgg8
conv3_weight_convgh9
conv3_weight_convgi9
conv3_weight_convgj9
conv3_weight_convgk9
conv3_weight_convgl9
conv3_weight_convgm9
conv3_weight_convgnb
conv3_weight_convgob
conv3_weight_convgpb
conv3_weight_convgqb
conv3_weight_convgrb
conv3_weight_convgsb
conv3_weight_convgtb
conv3_weight_convgub
conv3_weight_convgvb
conv3_weight_convgwb
conv3_weight_convgxb
conv3_weight_convgyb
conv3_weight_convgzb
conv3_weight_convgAb
conv3_weight_convgBb
conv3_weight_convgCb
conv3_weight_convgDb
conv3_weight_convgEb
conv3_weight_convgFb
conv3_weight_convgGb
conv3_weight_convgHb
conv3_weight_convgIb
conv3_weight_convgJb
conv3_weight_convgKb
conv3_weight_convgLb
conv3_weight_convgMb
conv3_weight_convgNb_x
conv3_weight_convgOb_x
conv3_weight_convgPb_x
conv3_weight_convgQb_x
conv3_weight_convgRb_x
conv3_weight_convgSb_x
conv3_weight_convgTb_x
conv3_weight_convgUb_x
conv3_weight_convgVb_x
conv3_weight_convgWb_x
conv3_weight_convgXb_x
conv3_weight_convgYb_x
conv3_weight_convgZb_x
conv3_weight_convg0b
conv3_weight_convg1b
conv3_weight_convg2b
conv3_weight_convg3b
conv3_weight_convg4b
conv3_weight_convg5b
conv3_weight_convg6b
conv3_weight_convg7b
conv3_weight_convg8b
conv3_weight_convg9b
conv3_weight_convhab
conv3_weight_convhbb
conv3_weight_convhcb
conv3_weight_convhdb
conv3_weight_convheb
conv3_weight_convhfb
conv3_weight_convhgb
conv3_weight_convhhb
conv3_weight_convhib
conv3_weight_convhjb
conv3_weight_convhkb
conv3_weight_convhlb
conv3_weight_convhmb
conv3_weight_convhnb
conv3_weight_convhob
conv3_weight_convhpb
conv3_weight_convhqb
conv3_weight_convhrb
conv3_weight_convhsb
conv3_weight_convhtb
conv3_weight_convhub
conv3_weight_convhvb
conv3_weight_convhwb
conv3_weight_convhxb
conv3_weight_convhyb
conv3_weight_convhzb
conv3_weight_convhAb_x
conv3_weight_convhBb_x
conv3_weight_convhCb_x
conv3_weight_convhDb_x
conv3_weight_convhEb_x
conv3_weight_convhFb_x
conv3_weight_convhGb_x
conv3_weight_convhHb_x
conv3_weight_convhIb_x
conv3_weight_convhJb_x
conv3_weight_convhKb_x
conv3_weight_convhLb_x
conv3_weight_convhMb_x
conv3_weight_convhNb_x
conv3_weight_convhOb_x
conv3_weight_convhPb_x
conv3_weight_convhQb_x
conv3_weight_convhRb_x
conv3_weight_convhSb_x
conv3_weight_convhTb_x
conv3_weight_convhUb_x
conv3_weight_convhVb_x
conv3_weight_convhWb_x
conv3_weight_convhXb_x
conv3_weight_convhYb_x
conv3_weight_convhZb_x
conv3_weight_convh0b
conv3_weight_convh1b
conv3_weight_convh2b
conv3_weight_convh3b
conv3_weight_convh4b
conv3_weight_convh5b
conv3_weight_convh6b
conv3_weight_convh7b
conv3_weight_convh8b
conv3_weight_convh9b
conv3_weight_conviab
conv3_weight_convibb
conv3_weight_convicb
conv3_weight_convidb
conv3_weight_convieb
conv3_weight_convifb
conv3_weight_convigb
conv3_weight_convihb
conv3_weight_conviib
conv3_weight_convijb
conv3_weight_convikb
conv3_weight_convilb
conv3_weight_convimb
conv3_weight_convinb
conv3_weight_conviob
conv3_weight_convipb
conv3_weight_conviqb
conv3_weight_convirb
conv3_weight_convisb
conv3_weight_convitb
conv3_weight_conviub
conv3_weight_convivb
conv3_weight_conviwb
conv3_weight_convixb
conv3_weight_conviyb
conv3_weight_convizb
conv3_weight_conviAb_x
conv3_weight_conviBb_x
conv3_weight_conviCb_x
conv3_weight_conviDb_x
conv3_weight_conviEb_x
conv3_weight_conviFb_x
conv3_weight_conviGb_x
conv3_weight_conviHb_x
conv3_weight_conviIb_x
conv3_weight_conviJb_x
conv3_weight_conviKb_x
conv3_weight_conviLb_x
conv3_weight_conviMb_x
conv3_weight_conviNb_x
conv3_weight_conviOb_x
conv3_weight_conviPb_x
conv3_weight_conviQb_x
conv3_weight_conviRb_x
conv3_weight_conviSb_x
conv3_weight_conviTb_x
conv3_weight_conviUb_x
conv3_weight_conviVb_x
conv3_weight_conviWb_x
conv3_weight_conviXb_x
conv3_weight_conviYb_x
conv3_weight_conviZb_x
conv3_weight_convi0b
conv3_weight_convi1b
conv3_weight_convi2b
conv3_weight_convi3b
conv3_weight_convi4b
conv3_weight_convi5b
conv3_weight_convi6b
conv3_weight_convi7b
conv3_weight_convi8b
conv3_weight_convi9b
conv3_weight_convjab
conv3_weight_convjbb
conv3_conv3_line_jcb
conv3_conv3_line_kJb_x
conv3_conv3_windokKb
conv3_conv3_windokLb
test_mac_muladd_1kYb
relu_bn3_a_batchnkWb
relu_bn3_b_batchnkXb
maxpool3_pool3_likZb
maxpool3_pool3_wik0b
test_mux_646_5_1_1
test_mac_muladd_6opc
test_mac_muladd_6oqc
conv4_weight_convk1b
conv4_weight_convk2b
conv4_weight_convk3b
conv4_weight_convk4b
conv4_weight_convk5b
conv4_weight_convk6b
conv4_weight_convk7b
conv4_weight_convk8b
conv4_weight_convk9b
conv4_conv4_line_lab
conv4_conv4_line_ofc
conv4_conv4_windoogc
conv4_conv4_windoohc
test_mac_muladd_1otc
relu_bn4_a_batchnorc
relu_bn4_b_batchnosc
maxpool4_pool4_liouc
test_mux_32_5_1_1
conv5_weight_convowc
conv5_weight_convoxc
conv5_weight_convoyc
conv5_weight_convozc
conv5_weight_convoAc
conv5_weight_convoBc
conv5_weight_convoCc
conv5_weight_convoDc
conv5_weight_convoEc
conv5_conv5_line_oFc
conv5_conv5_line_rKc_x
test_mac_muladd_1rWc
relu_bn5_a_batchnrUc
relu_bn5_b_batchnrVc
conv6_weight_convrXc
conv6_weight_convrYc
conv6_weight_convrZc
conv6_weight_convr0c
conv6_weight_convr1c
conv6_weight_convr2c
conv6_weight_convr3c
conv6_weight_convr4c
conv6_weight_convr5c
test_mac_muladd_1vnd
relu_bn6_a_batchnvld
relu_bn6_b_batchnvmd
conv7_weight_convvod
conv7_weight_convvpd
conv7_weight_convvqd
conv7_weight_convvrd
conv7_weight_convvsd
conv7_weight_convvtd
conv7_weight_convvud
conv7_weight_convvvd
conv7_weight_convvwd
relu_bn7_a_batchnyMd
relu_bn7_b_batchnyNd
conv8_weight_convyOd
conv8_weight_convyPd
conv8_weight_convyQd
conv8_weight_convyRd
conv8_weight_convySd
conv8_weight_convyTd
conv8_weight_convyUd
conv8_weight_convyVd
conv8_weight_convyWd
test_mac_muladd_1Cee
relu_bn8_a_batchnCce
relu_bn8_b_batchnCde
fifo_w16_d128_A
fifo_w32_d20_A
fifo_w5_d128_A
fifo_w5_d128_A
fifo_w16_d128_A
fifo_w5_d128_A
fifo_w5_d128_A
fifo_w16_d128_A
fifo_w5_d128_A
fifo_w5_d128_A
fifo_w16_d128_A
fifo_w5_d128_A
fifo_w5_d128_A
fifo_w16_d128_A
fifo_w5_d128_A
fifo_w16_d128_A
fifo_w5_d128_A
fifo_w16_d128_A
fifo_w5_d128_A
fifo_w16_d128_A
start_for_relu_bnCfe
start_for_relu_bnCge
start_for_maxpoolChe
start_for_conv2_U0
start_for_relu_bnCie
start_for_maxpoolCje
start_for_conv3_U0
start_for_relu_bnCke
start_for_maxpoolCle
start_for_conv4_U0
start_for_relu_bnCme
start_for_maxpoolCne
start_for_conv5_U0
start_for_relu_bnCoe
start_for_conv6_U0
start_for_relu_bnCpe
start_for_conv7_U0
start_for_relu_bnCqe
start_for_conv8_U0
test_control_s_axi
test_gmem_m_axi
conv113
relu_bn1
maxpool1
conv2
relu_bn2
maxpool2
conv3
relu_bn3
maxpool3
conv4
relu_bn4
maxpool4
conv5
relu_bn5
conv6
relu_bn6
conv7
relu_bn7
conv8
relu_bn8
test
}
set kernel_xo ""

## Variables
set Top "test"
set TopNoPrefix "test"
set VhdlFiles [sort_file_names [glob -nocomplain hdl/vhdl/*] ${Top}.vhd]
set VerilogFiles [sort_file_names [glob -nocomplain hdl/verilog/*] ${Top}.v]
set SWDriverFiles [sort_file_names [glob-r drivers]]
set SubcoreFiles [sort_file_names [glob -nocomplain subcore/*]]
set DocumentFiles [sort_file_names [glob -nocomplain doc/*]]
set BDFiles [sort_file_names [glob -nocomplain bd/*]]
set ConstraintFiles [sort_file_names [glob -nocomplain constraints/*]]
set MiscFiles [sort_file_names [glob -nocomplain misc/*]]
set Interfaces {
    s_axi_control {
        type "axi4lite"
        mode "slave"
        port_prefix "s_axi_control"
        param_prefix "C_S_AXI_CONTROL"
        addr_bits "5"
        port_width "AWADDR 5 WDATA 32 WSTRB 4 ARADDR 5 RDATA 32"
        registers {{0x00 CTRL       RW   0x0 "Control signals" {{ 0 1 AP_START RW 0 "Control signal Register for 'ap_start'." } { 1 1 AP_DONE R 0 "Control signal Register for 'ap_done'." } { 2 1 AP_IDLE R 0 "Control signal Register for 'ap_idle'." } { 3 1 AP_READY R 0 "Control signal Register for 'ap_ready'." } { 4 3 RESERVED_1 R 0 "Reserved.  0s on read." } { 7 1 AUTO_RESTART RW 0 "Control signal Register for 'auto_restart'." } { 8 24 RESERVED_2 R 0 "Reserved.  0s on read." }}} {0x04 GIER       RW   0x0 "Global Interrupt Enable Register" {{ 0 1 Enable RW 0 "Master enable for the device interrupt output to the system interrupt controller: 0 = Disabled, 1 = Enabled" } { 1 31 RESERVED R 0 "Reserved.  0s on read." }} } {0x08 IP_IER     RW   0x0 "IP Interrupt Enable Register" {{ 0 1 CHAN0_INT_EN RW 0 "Enable Channel 0 (ap_done) Interrupt.  0 = Disabled, 1 = Enabled." } { 1 1 CHAN1_INT_EN RW 0 "Enable Channel 1 (ap_ready) Interrupt.  0 = Disabled, 1 = Enabled." } { 2 30 RESERVED R 0 "Reserved.  0s on read." }}} {0x0c IP_ISR     RW   0x0 "IP Interrupt Status Register" {{ 0 1 CHAN0_INT_ST RTOW 0 "Channel 0 (ap_done) Interrupt Status. 0 = No Channel 0 input interrupt, 1 = Channel 0 input interrup" } { 1 1 CHAN1_INT_ST RTOW 0 "Channel 1 (ap_ready) Interrupt Status. 0 = No Channel 1 input interrupt, 1 = Channel 1 input interrup" } { 2 30 RESERVED R 0 "Reserved.  0s on read." }}} {0x10 input_image W 0x0 "Data signal of input_image" {{0 32 input_image W 0 "Bit 31 to 0 Data signal of input_image"}}} {0x18 result W 0x0 "Data signal of result" {{0 32 result W 0 "Bit 31 to 0 Data signal of result"}}}}
        memories ""
        ctype {
            AWVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            AWREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            WVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            WREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            BVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            BREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            BRESP {
                Type "integer unsigned"
                Width "2"
                Bits "2"
            }
            ARVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            ARREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            RVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            RREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            RRESP {
                Type "integer unsigned"
                Width "2"
                Bits "2"
            }
            AWADDR {
                Type "integer unsigned"
                Width "5"
                Bits "5"
            }
            WDATA {
                Type "null"
                Width "32"
                Bits "32"
            }
            WSTRB {
                Type "integer unsigned"
                Width "4"
                Bits "4"
            }
            ARADDR {
                Type "integer unsigned"
                Width "5"
                Bits "5"
            }
            RDATA {
                Type "null"
                Width "32"
                Bits "32"
            }
        }
        data_width "32"
    }
    ap_clk {
        type "clock"
        ctype {
            CLK {
                Type "bool"
                Width "1"
                Bits "1"
            }
        }
        buses "s_axi_control m_axi_gmem"
        reset "ap_rst_n"
    }
    ap_rst_n {
        type "reset"
        polarity "ACTIVE_LOW"
        ctype {
            RST {
                Type "bool"
                Width "1"
                Bits "1"
            }
        }
    }
    interrupt {
        type "interrupt"
        ctype {
            INTERRUPT {
                Type "bool"
                Width "1"
                Bits "1"
            }
        }
    }
    m_axi_gmem {
        type "native_axim"
        mode "master"
        port_prefix "m_axi_gmem"
        data_width "32"
        param_prefix "C_M_AXI_GMEM"
        port_width "AWADDR 32 AWID 1 AWUSER 1 WDATA 32 WSTRB 4 WID 1 WUSER 1 ARADDR 32 ARID 1 ARUSER 1 RDATA 32 RID 1 RUSER 1 BID 1 BUSER 1"
        ctype {
            AWLEN {
                Type "integer unsigned"
                Width "8"
                Bits "8"
            }
            AWSIZE {
                Type "integer unsigned"
                Width "3"
                Bits "3"
            }
            AWBURST {
                Type "integer unsigned"
                Width "2"
                Bits "2"
            }
            AWLOCK {
                Type "integer unsigned"
                Width "2"
                Bits "2"
            }
            AWREGION {
                Type "integer unsigned"
                Width "4"
                Bits "4"
            }
            AWCACHE {
                Type "integer unsigned"
                Width "4"
                Bits "4"
            }
            AWPROT {
                Type "integer unsigned"
                Width "3"
                Bits "3"
            }
            AWQOS {
                Type "integer unsigned"
                Width "4"
                Bits "4"
            }
            AWVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            AWREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            WLAST {
                Type "bool"
                Width "1"
                Bits "1"
            }
            WVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            WREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            BVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            BREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            BRESP {
                Type "integer unsigned"
                Width "2"
                Bits "2"
            }
            ARLEN {
                Type "integer unsigned"
                Width "8"
                Bits "8"
            }
            ARSIZE {
                Type "integer unsigned"
                Width "3"
                Bits "3"
            }
            ARBURST {
                Type "integer unsigned"
                Width "2"
                Bits "2"
            }
            ARLOCK {
                Type "integer unsigned"
                Width "2"
                Bits "2"
            }
            ARREGION {
                Type "integer unsigned"
                Width "4"
                Bits "4"
            }
            ARCACHE {
                Type "integer unsigned"
                Width "4"
                Bits "4"
            }
            ARPROT {
                Type "integer unsigned"
                Width "3"
                Bits "3"
            }
            ARQOS {
                Type "integer unsigned"
                Width "4"
                Bits "4"
            }
            ARVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            ARREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            RLAST {
                Type "bool"
                Width "1"
                Bits "1"
            }
            RVALID {
                Type "bool"
                Width "1"
                Bits "1"
            }
            RREADY {
                Type "bool"
                Width "1"
                Bits "1"
            }
            RRESP {
                Type "integer unsigned"
                Width "2"
                Bits "2"
            }
            AWADDR {
                Type "integer unsigned"
                Width "32"
                Bits "32"
            }
            AWID {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            AWUSER {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            WDATA {
                Type "real float"
                Width "32"
                Bits "32"
            }
            WSTRB {
                Type "integer unsigned"
                Width "4"
                Bits "4"
            }
            WID {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            WUSER {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            ARADDR {
                Type "integer unsigned"
                Width "32"
                Bits "32"
            }
            ARID {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            ARUSER {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            RDATA {
                Type "real float"
                Width "32"
                Bits "32"
            }
            RID {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            RUSER {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            BID {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
            BUSER {
                Type "integer unsigned"
                Width "1"
                Bits "1"
            }
        }
        HasOffset "1"
        preferred_usage_value "MEMORY"
        has_dependant_on "1"
        offset_slave_name "s_axi_control"
        NUM_READ_OUTSTANDING "16"
        NUM_WRITE_OUTSTANDING "16"
        MAX_READ_BURST_LENGTH "16"
        MAX_WRITE_BURST_LENGTH "16"
    }
}

set vivado_ver [version -short]
if {[regexp -nocase {2015\.1.*} $vivado_ver match]} {
    set user_param_type "std_logic_vector"
} else {
    set user_param_type "integer"
}

######################## Helper functions #################
variable user_parameter_order 1

proc add_port {core name dir width param args} {
    # {{{
    catch {ipx::remove_port $name $core}
    set current_port [ipx::add_port $name $core]
    set_property direction $dir $current_port
    if {$width == ""} {
        # std_logic
        set_property type_name "std_logic" $current_port
        set_property is_vector "false" $current_port
    } else {
        # std_logic_vector
        # width should be an integer
        set_property size_left [expr $width - 1] $current_port
        if {$param != ""} {
            if {[string range $param end-1 end] == "/8"} {
                # for strobe
                set param [string range $param 0 end-2]
                set_property size_left_dependency "((spirit:decode(id('MODELPARAM_VALUE.$param')) div 8) - 1)" $current_port
            } else {
                set_property size_left_dependency "(spirit:decode(id('MODELPARAM_VALUE.$param')) - 1)" $current_port
            }
            set_property size_left_resolve_type "dependent" $current_port
        } else {
            set_property size_left_resolve_type "immediate" $current_port
        }
        set_property size_left_format_type "long" $current_port
        set_property size_right 0 $current_port
        set_property size_right_resolve_type "immediate" $current_port
        set_property size_right_format_type "long" $current_port
        set_property type_name "std_logic_vector" $current_port
        set_property is_vector "true" $current_port
    }

    foreach {k v} $args {
        set_property $k $v $current_port
    }

    return $current_port
    # }}}
}

proc add_hdl_parameter {core name type value format resolve_type args} {
    # {{{
    set current_hdl_parameter [ipx::add_hdl_parameter $name $core]
    set_property data_type $type $current_hdl_parameter
    set_property value $value $current_hdl_parameter
    set_property value_format $format $current_hdl_parameter
    set_property value_resolve_type $resolve_type $current_hdl_parameter
    foreach {k v} $args {
        set_property $k $v $current_hdl_parameter
    }

    return $current_hdl_parameter
    # }}}
}

proc add_bus_interface {core name type mode {preferred_usage_value "ALL"} {has_dependant_on "0"} {offset_slave_name "s_axi_AXILiteS"} {master_addrwidth "32"}} {
    # {{{
    set properties ""
    switch -- $type {
        axi4 -
        axi4lite {
            dict set properties bus_type_vlnv "xilinx.com:interface:aximm:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:interface:aximm_rtl:1.0"
            dict set properties endianness "little"
            dict set properties interface_mode $mode
            if {$mode == "master"} {
                set ::AddressSpace [ipx::add_address_space Data_$name $core]
                if {$master_addrwidth == "64"} {
                    set_property range 16E $::AddressSpace
                    set_property width 64 $::AddressSpace
                } else {
                    set_property range 4G $::AddressSpace
                    set_property width 32 $::AddressSpace
                }
                if {$has_dependant_on == "1"} {
                   set current_addrspace_param [ipx::add_address_space_parameter DEPENDENT_ON $::AddressSpace]
                   set_property value $offset_slave_name $current_addrspace_param
                }
                set current_addrspace_param [ipx::add_address_space_parameter PREFERRED_USAGE $::AddressSpace]
                set_property value $preferred_usage_value $current_addrspace_param
                dict set properties master_address_space_ref Data_$name
            }
            if {$mode == "slave"} {
                set current_memory_map [ipx::add_memory_map $name $core]
                set current_address_block [ipx::add_address_block Reg $current_memory_map]
                set_property width "32" $current_address_block
                set_property access "read-write" $current_address_block
                set_property usage "register" $current_address_block
                set_property base_address "0" $current_address_block
                set_property base_address_format "long" $current_address_block
                set_property base_address_resolve_type "immediate" $current_address_block
                set_property range "65536" $current_address_block
                set_property range_format "long" $current_address_block
                set_property range_resolve_type "generated" $current_address_block
                set current_parameter [ipx::add_address_block_parameter ${name}_base_addr $current_address_block]
                set_property name OFFSET_BASE_PARAM $current_parameter
                set_property value C_[string toupper $name]_BASEADDR $current_parameter
                set current_parameter [ipx::add_address_block_parameter ${name}_high_addr $current_address_block]
                set_property name OFFSET_HIGH_PARAM $current_parameter
                set_property value C_[string toupper $name]_HIGHADDR $current_parameter
                dict set properties slave_memory_map_ref $name
            }
        }
        axi4stream {
            dict set properties bus_type_vlnv "xilinx.com:interface:axis:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:interface:axis_rtl:1.0"
            dict set properties endianness "little"
            dict set properties interface_mode $mode
        }
        bram {
            dict set properties bus_type_vlnv "xilinx.com:interface:bram:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:interface:bram_rtl:1.0"
            dict set properties interface_mode $mode
        }
        fifo_read {
            dict set properties bus_type_vlnv "xilinx.com:interface:acc_fifo_read:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:interface:acc_fifo_read_rtl:1.0"
            dict set properties interface_mode $mode
        }
        fifo_write {
            dict set properties bus_type_vlnv "xilinx.com:interface:acc_fifo_write:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:interface:acc_fifo_write_rtl:1.0"
            dict set properties interface_mode $mode
        }
        ap_ctrl {
            dict set properties bus_type_vlnv "xilinx.com:interface:acc_handshake:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:interface:acc_handshake_rtl:1.0"
            dict set properties interface_mode $mode
        }
        clock {
            dict set properties bus_type_vlnv "xilinx.com:signal:clock:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:signal:clock_rtl:1.0"
            dict set properties interface_mode "slave"
        }
        reset {
            dict set properties bus_type_vlnv "xilinx.com:signal:reset:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:signal:reset_rtl:1.0"
            dict set properties interface_mode "slave"
        }
        clockenable {
            dict set properties bus_type_vlnv "xilinx.com:signal:clockenable:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:signal:clockenable_rtl:1.0"
            dict set properties interface_mode "slave"
        }
        interrupt {
            dict set properties bus_type_vlnv "xilinx.com:signal:interrupt:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:signal:interrupt_rtl:1.0"
            dict set properties interface_mode "master"
        }
        data {
            dict set properties bus_type_vlnv "xilinx.com:signal:data:1.0"
            dict set properties abstraction_type_vlnv "xilinx.com:signal:data_rtl:1.0"
            dict set properties interface_mode $mode
        }
    }

    set current_bus_interface [ipx::add_bus_interface $name $core]
    dict for {k v} $properties {
        set_property $k $v $current_bus_interface
    }

    return $current_bus_interface
    # }}}
}

proc add_port_map {bus name logical physical} {
    # {{{
    set current_port_map [ipx::add_port_map $name $bus]
    set_property logical_name $logical $current_port_map
    set_property physical_name $physical $current_port_map

    return $current_port_map
    # }}}
}

proc add_bus_parameter {bus name value {resolve_type ""}} {
    # {{{
    if {$resolve_type == ""} {
        set resolve_type "immediate"
    }

    set current_bus_parameter [ipx::add_bus_parameter $name $bus]
    set_property value $value $current_bus_parameter
    set_property value_resolve_type $resolve_type $current_bus_parameter

    return $current_bus_parameter
    # }}}
}

proc add_user_parameter {core name display_name value format resolve_type args} {
    # {{{
    upvar user_parameter_order order
    incr order
    
    set current_user_parameter [ipx::add_user_parameter $name $core]
    set_property order $order $current_user_parameter
    set_property value $value $current_user_parameter
    set_property display_name $display_name $current_user_parameter
    set_property value_format $format $current_user_parameter
    set_property value_resolve_type $resolve_type $current_user_parameter
    foreach {k v} $args {
        set_property $k $v $current_user_parameter
    }

    return $current_user_parameter
    # }}}
}

proc create_datatype { ctype {bitoffset 0} {is_data 0}} {
    # {{{
    dict with ctype {}

    switch -- [lindex $Type 0] {
        integer {
            # integer
            if {[lindex $Type 1] == "signed"} {
                set signed true
            } else {
                set signed false
            }
            if {$is_data} {
               return [iptypes::datatype::new -type integer -bitwidth $Bits -bitoffset $bitoffset -signed $signed]
            } else {
               return [iptypes::datatype::new -type integer -bitwidth $Width -bitoffset $bitoffset -signed $signed]
            }
        }

        real {
            lassign $Type type sub_type signed frac_width
            if {$sub_type == "fixed"} {
                # real - fixed
                if {$signed == "signed"} {
                    set signed true
                } else {
                    set signed false
                }
                return [iptypes::datatype::new -type real -bitwidth $Width -bitoffset $bitoffset -fixed \
                    -signed $signed -fractwidth $frac_width]
            } else {
                # real -float
                set sigwidth [expr ($Width == 64)? 53 : 24]
                return [iptypes::datatype::new -type real -bitwidth $Width -bitoffset $bitoffset -float -sigwidth $sigwidth]
            }
        }

        complex {
            dict with Element {}

            if {$Bits % 8 != 0} {
                set ::__warn_sub_field__ 1
            }

            switch -- [lindex $Type 0] {
                integer {
                    # integer
                    if {[lindex $Type 1] == "signed"} {
                        set signed true
                    } else {
                        set signed false
                    }
                    return [iptypes::datatype::new -type complex -bitwidth $Width -stride $Bits -bitoffset $bitoffset -integer -signed $signed]
                }

                real {
                    lassign $Type type sub_type signed frac_width
                    if {$sub_type == "fixed"} {
                        # real - fixed
                        if {$signed == "signed"} {
                            set signed true
                        } else {
                            set signed false
                        }
                        return [iptypes::datatype::new -type complex -bitwidth $Width -stride $Bits -bitoffset $bitoffset -real -fixed \
                            -signed $signed -fractwidth $frac_width]
                    } else {
                        # real -float
                        set sigwidth [expr ($Width == 64)? 53 : 24]
                        return [iptypes::datatype::new -type complex -bitwidth $Width -stride $Bits -bitoffset $bitoffset -real -float -sigwidth $sigwidth]
                    }
                }
            }
        }

        struct {
            set type [iptypes::datatype::new -type struct -bitoffset $bitoffset]

            set i 0
            dict for {field_name field_type} $Fields {
                iptypes::struct::new_field type -name $field_name -datatype [create_datatype $field_type $i]
                incr i [dict get $field_type Bits]
            }

            return $type
        }

        array {
            return [iptypes::datatype::new -type array_type -bitoffset $bitoffset -size $Dimension \
                -stride [dict get $Element Bits] -datatype [create_datatype $Element]]
        }

        null    -
        default {
            # null
            return [iptypes::datatype::new -bitwidth $Width -bitoffset $bitoffset]
        }
    }
    # }}}
}

proc add_bus_datatype {bus ctype {is_data 0}} {
    # {{{
    if {$::SupportDataType && $ctype != ""} {
        set layered_metadata ""
        dict for {key value} $ctype {
            dict set layered_metadata $iptypes::vlnv $key [create_datatype $value 0 $is_data]
        }
        add_bus_parameter $bus LAYERED_METADATA $layered_metadata generated
    }
    # }}}
}

proc set_dependent { name value obj } {
    # {{{
   # are there any operators in the value field?
   # No, set as immediate
   # Yes, set as xpath expr
   if { [string first < $value ] != -1 || \
        [string first > $value ] != -1 || \
        [string first - $value ] != -1 || \
        [string first + $value ] != -1 || \
        [string first / $value ] != -1 || \
        [string first * $value ] != -1 } {
     set_property ${name}_dependency [ ipx::get_xpath_expression $value [ipx::current_core] ] $obj
     set_property ${name}_format long $obj
   } else {
     set_property ${name} $value $obj
     set_property ${name}_format long $obj
   }
    # }}}
}

proc set_access { access obj {is_field 0}} {
    # {{{
  # read-only, write-only, read-write, writeOnce, read-writeOnce 
  if        { $access eq "RW" } {
             set_property access "read-write" $obj
             if {$is_field} {
               set_property modified_write_value modify $obj 
             }
  } elseif { $access eq "R" } {
             set_property access "read-only" $obj
             if {$is_field} {
               set_property read_action modify $obj 
             }
  } elseif { $access eq "W" } {
             set_property access "write-only" $obj
  } elseif { $access eq "WO" } {
             set_property access "writeOnce" $obj
  } elseif { $access eq "RWO" } {
             set_property access "read-writeOnce" $obj
  } elseif { $access eq "RTOW" } {
             set_property access "read-only" $obj 
             if {$is_field} {
               set_property modified_write_value oneToToggle $obj 
               set_property read_action modify $obj 
             }
  } else {
    puts "Unmatched access type \"$access\""
  }

    # }}}
}

proc add_registers {registers memory_map_name} {
    # {{{
    set memory_maps [ ipx::get_memory_maps -quiet -of_objects [ ipx::current_core ] ] 
    if { $memory_maps eq "" } {
      set slaves_axi [ ipx::get_bus_interfaces -filter { ABSTRACTION_TYPE_NAME==aximm_rtl && interface_mode==slave } -of_objects [ ipx::current_core ] ]
      set slave_axi [ lindex $slaves_axi 0  ] 
      set memory_map [ ipx::add_memory_map [ get_property name $slave_axi ] [ipx::current_core ] ]
      # and point back to this memory map
      set_property  slave_memory_map_ref [get_property name $memory_map ] $slave_axi 
    } else {
      foreach memory_map_item $memory_maps {
        set memory_map_item_name [get_property name $memory_map_item]
        if {$memory_map_name eq $memory_map_item_name} {
          set memory_map $memory_map_item
        }
      }
    }
    
    set address_blocks [ ipx::get_address_blocks -quiet -of_objects $memory_map ]
    if { $address_blocks eq "" } {
      set address_block [ ipx::add_address_block [get_property name $memory_map ] $memory_map ]
      set_property base_address 0 $address_block 
      set_property range 4096 $address_block 
      set_property width 8 $address_block 
    } else {
      set address_block [ lindex $address_blocks 0 ]
    }
    
    
    foreach reg $registers {
      set offset [ lindex $reg 0 ]
      set name   [ lindex $reg 1 ]
      set access [ lindex $reg 2 ]
      set reset_val [ lindex $reg 3 ]
      set descr  [ lindex $reg 4 ]
      set fields  [ lindex $reg 5 ]
    
    #puts "Register line: [join $reg \"]"
    
      # compare offset and address range, if offset > default address rang(64k), we should expand the address range
      set address_range  [get_property range $address_block]
      set offset_value [::math::bignum::tostr  [ ::math::bignum::fromstr $offset ] ]
      while {$address_range <= $offset_value} {
          set address_range [expr $address_range * 2]
      }
    
      set_property range $address_range $address_block
      set ipx_reg [ ipx::add_register $name $address_block ]
      set_property address_offset $offset_value $ipx_reg 
      set_property size 32 $ipx_reg 
      set_property size_format long $ipx_reg 
      set_property reset_value  [::math::bignum::tostr [ ::math::bignum::fromstr $reset_val ] ] $ipx_reg 
      set_property reset_value_format long $ipx_reg 
      set_property description $descr $ipx_reg 
      set_property display_name $name $ipx_reg 
    
      # read-only, write-only, read-write, writeOnce, read-writeOnce 
      set_access $access $ipx_reg
    
      foreach field $fields {
    #puts "  field line: [join $field \"]"
         set offset [ lindex $field 0 ]
         set width [ lindex $field 1 ]
         set name [ lindex $field 2 ]
         set access [ lindex $field 3 ]
         set reset_value [ lindex $field 4 ]
         set description [ lindex $field 5 ]
    
         set ipx_field [ ipx::add_field $name $ipx_reg ]
         set_property bit_offset $offset $ipx_field
    
         set_dependent bit_width $width $ipx_field
         set_access $access $ipx_field 1
    
         #  set_property reset_value  [::math::bignum::tostr [ ::math::bignum::fromstr $offset ] ] $ipx_field 
         # set_property reset_value_format long $ipx_field 
         set_property description $description $ipx_field 
      }
    
    }

    # }}}
}

proc add_memories {memories memory_map_name} {
    # {{{
    set memory_maps [ ipx::get_memory_maps -quiet -of_objects [ ipx::current_core ] ] 
    if { $memory_maps eq "" } {
      set slaves_axi [ ipx::get_bus_interfaces -filter { ABSTRACTION_TYPE_NAME==aximm_rtl && interface_mode==slave } -of_objects [ ipx::current_core ] ]
      set slave_axi [ lindex $slaves_axi 0  ] 
      set memory_map [ ipx::add_memory_map [ get_property name $slave_axi ] [ipx::current_core ] ]
      # and point back to this memory map
      set_property  slave_memory_map_ref [get_property name $memory_map ] $slave_axi 
    } else {
      foreach memory_map_item $memory_maps {
        set memory_map_item_name [get_property name $memory_map_item]
        if {$memory_map_name eq $memory_map_item_name} {
          set memory_map $memory_map_item
        }
      }
    }

    set address_blocks [ ipx::get_address_blocks -quiet -of_objects $memory_map ]
    if { $address_blocks eq "" } {
      set address_block [ ipx::add_address_block [get_property name $memory_map ] $memory_map ]
      set_property base_address 0 $address_block 
      set_property range 4096 $address_block 
      set_property width 8 $address_block 
    } else {
      set address_block [ lindex $address_blocks 0 ]
    }
    
    
    dict for {array_name details} $memories {
      dict with details {}
      set offset $base_address
      set name   Memory_${array_name}
      set access RW
      set reset_val 0
      set descr  "Memory $array_name"
    
      # compare offset and address range, if offset > default address rang(64k), we should expand the address range
      set address_range  [get_property range $address_block]
      set offset_value [::math::bignum::tostr  [ ::math::bignum::fromstr $offset ] ]
      set address_range_tmp [expr $offset_value + $range ]
      while {$address_range < $address_range_tmp} {
          set address_range [expr $address_range * 2]
      }
    
      set_property range $address_range $address_block
      set ipx_reg [ ipx::add_register $name $address_block ]
      set_property address_offset $offset_value $ipx_reg 
      set_property size $range $ipx_reg 
      set_property size_format long $ipx_reg 
      set_property reset_value  [::math::bignum::tostr [ ::math::bignum::fromstr $reset_val ] ] $ipx_reg 
      set_property reset_value_format long $ipx_reg 
      set_property description $descr $ipx_reg 
      set_property display_name $name $ipx_reg 
    
      # read-only, write-only, read-write, writeOnce, read-writeOnce 
      set_access $access $ipx_reg
    }
    # }}}
}

proc getFiles {path} {
    # {{{
    set files ""
    foreach item [glob -nocomplain [file join $path *]] {
        if {[file isdir $item]} {
            set files [concat $files [getFiles $item]]
        } else {
            lappend files $item
        }
    }

    return [lsort $files]
    # }}}
}
###########################################################

## Enter IP directory
cd [file dir [info script]]

## Generate sub cores
set IPs ""
set IPFiles ""
if {$SubcoreFiles != ""} {
    set ipdir "hdl/ip"
    file delete -force $ipdir
    file mkdir $ipdir

    set prj "tmp"
    create_project -part $target_part -force $prj
    set_property target_language $target_lang [current_project]
    if {[regexp -nocase {2018\.4.*} $vivado_ver match]} {
        set_property coreContainer.alwaysCreateXCI 1 [current_project]
    }

    set COE_DIR ../../../..
    foreach ipfile $SubcoreFiles {
        set ipname [file root [file tail $ipfile]]
        set ipname [string range $ipname 0 end-3]

        source $ipfile
        if {[regexp -nocase {2018\.4.*} $vivado_ver match]} {
            extract_files -force -base_dir "./${prj}srcs/sources_1/ip" [get_files -all -of [get_ips $ipname]]
            file copy -force ./${prj}.srcs/sources_1/ip/$ipname.xci ./${prj}srcs/sources_1/ip/$ipname/.
            set prj_root "${prj}srcs"
        } else {
            set prj_root "${prj}.srcs"
        }

        set rtlfiles [glob -nocomplain ${prj_root}/sources_1/ip/$ipname/synth/*]
        foreach rtl $rtlfiles {
            file copy $rtl $ipdir
        }

        set rtlfiles [glob -nocomplain ${prj_root}/sources_1/ip/$ipname/*.mif]
        foreach rtl $rtlfiles {
            file copy $rtl $ipdir
        }

        set xcifile "${prj_root}/sources_1/ip/$ipname/$ipname.xci"
        if {![file isfile $xcifile]} {
            continue
        }

        set f [open $xcifile r]
        set s [read $f]
        close $f
        set pat {(?n)componentRef.*vendor="(.+)".*\s*.*library="(.+)".*\s*.*name="(.+)".*\s*.*version="(.+)".*\s*.*}
        if {[regexp $pat $s m vendor library name version]} {
            lappend IPs "$vendor:$library:$name:$version"
        }
    }

    close_project
    
    set IPs [lsort -u $IPs]
    set IPFiles [glob -nocomplain $ipdir/*]
}

## Basic info
set vivado_ver [version -short]
set core [ipx::create_core $Vendor $Library $IPName $Version]
set_property definition_source HLS [ipx::current_core]
set_property display_name $DisplayName $core
set_property core_revision $Revision $core
set_property description $Description $core
set_property taxonomy $Taxonomy $core
if { $AutoFamily ne "" } {
  set_property auto_family_support_level $AutoFamily $core
} else {
  set_property supported_families [list $Device Pre-Production] $core
}

if {$has_xpm_memory} {
  set_property xpm_libraries {XPM_MEMORY} $core
}
if {$sdx_kernel_type ne ""} {
  set_property -quiet sdx_kernel true $core
  set_property -quiet sdx_kernel_type $sdx_kernel_type $core
}
## Add verilog files
if {[llength $VerilogFiles] > 0} {
    # synthesis
    set group [ipx::add_file_group xilinx_verilogsynthesis $core]
    foreach f [concat $IPFiles $ConstraintFiles $VerilogFiles] {
        set current_file [ipx::add_file $f $group]
        if {[file ext $f] == ".dat" || [file ext $f] == ".mif"} {
            set_property type "mif" $current_file
        }
        if {[file ext $f] == ".xdc"} {
            if {[regexp -nocase {.*_ooc.xdc} $f]} {
                set_property used_in {out_of_context} $current_file
            } else {
                set_property used_in {synthesis implementation} $current_file
            }
        }
    }
    set_property model_name $Top $group
    if {$IPs != ""} {
        set_property component_subcores $IPs $group
    }

    # behavioral simulation
    set group [ipx::add_file_group xilinx_verilogbehavioralsimulation $core]
    foreach f [concat $VerilogFiles $IPFiles] {
        set current_file [ipx::add_file $f $group]
        if {[file ext $f] == ".dat" || [file ext $f] == ".mif"} {
            set_property type "mif" $current_file
        }
    }
    set_property model_name $Top $group
    if {$IPs != ""} {
        set_property component_subcores $IPs $group
    }

}

## Add vhdl files
if {[llength $VhdlFiles] > 0} {
    # synthesis
    set group [ipx::add_file_group xilinx_vhdlsynthesis $core]
    foreach f [concat $IPFiles $ConstraintFiles $VhdlFiles] {
        set current_file [ipx::add_file $f $group]
        if {[file ext $f] == ".xdc"} {
            if {[regexp -nocase {.*_ooc.xdc} $f]} {
                set_property used_in {out_of_context} $current_file
            } else {
                set_property used_in {synthesis implementation} $current_file
            }
        }
    }
    set_property model_name $Top $group
    if {$IPs != ""} {
        set_property component_subcores $IPs $group
    }

    # behavioral simulation
    set group [ipx::add_file_group xilinx_vhdlbehavioralsimulation $core]
    foreach f [concat $VhdlFiles $IPFiles] {
        ipx::add_file $f $group
    }
    set_property model_name $Top $group
    if {$IPs != ""} {
        set_property component_subcores $IPs $group
    }

}

## Software Drivers Files
if {[llength $SWDriverFiles] > 0} {
    set current_file_group [ipx::add_file_group xilinx_softwaredriver $core]
    foreach f $SWDriverFiles {
        set current_file [ipx::add_file $f $current_file_group]
        if {[file ext $f] == ".mdd"} {
            set_property type {driver_mdd} $current_file
        } elseif {[file ext $f] == ".tcl"} {
            set_property type {driver_tcl} $current_file
        } else {
            set_property type {driver_src} $current_file
        }
    }
}

## Add document files
if {[llength $DocumentFiles] > 0} {
    set group [ipx::add_file_group xilinx_documentation $core]
    foreach f $DocumentFiles {
        ipx::add_file $f $group
    }
}

## Add misc files
if {[llength $MiscFiles] > 0} {
    set group [ipx::add_file_group xilinx_miscfiles $core]
    foreach f $MiscFiles {
        ipx::add_file $f $group
    }
}

## BD files
if {[llength $BDFiles] > 0} {
    set group [ipx::add_file_group xilinx_block_diagram $core]
    foreach f $BDFiles {
        ipx::add_file $f $group
    }
}

## Import ports
ipx::add_ports_from_hdl \
    -top_level_hdl_file hdl/vhdl/$Top.vhd \
    -top_module_name $Top \
    -quiet \
    $core

## Interfaces
foreach interface_name [dict keys $Interfaces] {
    set interface_detail [dict get $Interfaces $interface_name]
    set ctype ""
    dict with interface_detail {}
    switch -nocase -- $type {
        axi4lite {
            # {{{
            ## direction
            if {$mode == "master"} {
                set dir0 "out"
                set dir1 "in"
            } else {
                set dir0 "in"
                set dir1 "out"
            }

            ## address width
            if {$mode == "master"} {
                set addr_bits 32
            } else {
               set addr_bits [dict get $port_width AWADDR]
            }

            ## rtl ports
            set rtl_ports [list \
                [list AWADDR  $dir0 $addr_bits "${param_prefix}_ADDR_WIDTH"] \
                [list AWVALID $dir0 "" ""] \
                [list AWREADY $dir1 "" ""] \
                [list WDATA   $dir0 32 "${param_prefix}_DATA_WIDTH"] \
                [list WSTRB   $dir0 4  "${param_prefix}_DATA_WIDTH/8"] \
                [list WVALID  $dir0 "" ""] \
                [list WREADY  $dir1 "" ""] \
                [list BRESP   $dir1 2  ""] \
                [list BVALID  $dir1 "" ""] \
                [list BREADY  $dir0 "" ""] \
                [list ARADDR  $dir0 $addr_bits "${param_prefix}_ADDR_WIDTH"] \
                [list ARVALID $dir0 "" ""] \
                [list ARREADY $dir1 "" ""] \
                [list RDATA   $dir1 32 "${param_prefix}_DATA_WIDTH"] \
                [list RRESP   $dir1 2  ""] \
                [list RVALID  $dir1 "" ""] \
                [list RREADY  $dir0 "" ""] \
            ]

            ## rtl parameters
            set rtl_parameters [list \
                [list ADDR_WIDTH "integer" $addr_bits "long" "generated"] \
                [list DATA_WIDTH "integer" 32 "long" "immediate"] \
            ]

            ## bus parameters
            set bus_parameters [list \
                [list ADDR_WIDTH $addr_bits] \
                [list DATA_WIDTH 32] \
                [list PROTOCOL AXI4LITE] \
                [list READ_WRITE_MODE READ_WRITE] \
            ]

            ## axi4
            set current_bus_interface [add_bus_interface $core $interface_name axi4lite $mode]

            ## ports
            foreach rtl_port $rtl_ports {
                lassign $rtl_port port_name port_dir port_width port_param
                add_port $core ${port_prefix}_$port_name $port_dir $port_width $port_param
            }

            ## rtl parameters
            foreach rtl_parameter $rtl_parameters {
                set pargs [lassign $rtl_parameter pname ptype pvalue pformat presolve_type]
                eval add_hdl_parameter \$core \${param_prefix}_\$pname \$ptype \$pvalue \$pformat \$presolve_type $pargs
            }

            ## bus parameters
            foreach bus_parameter $bus_parameters {
                lassign $bus_parameter pname pvalue
                add_bus_parameter $current_bus_interface $pname $pvalue
            }

            # port map
            foreach rtl_port $rtl_ports {
                set port_name [lindex $rtl_port 0]
                add_port_map $current_bus_interface $port_name $port_name ${port_prefix}_${port_name}
            }

            # data type
            add_bus_datatype $current_bus_interface $ctype

            # add registers
            if {[info exists registers] && $registers!=""} {
               add_registers $registers $interface_name
            }

            # add memories
            if {[info exists memories] && $memories!=""} {
               add_memories $memories $interface_name
            }
            # }}}
        }

        axi4stream {
            # {{{
            ## ports
            if {$mode == "master"} {
                set dir0 "out"
                set dir1 "in"
            } else {
                set dir0 "in"
                set dir1 "out"
            }

            ## bus parameters
            set bus_parameters ""


            if {[dict exists $ports TDATA]} {
                lappend bus_parameters [list TDATA_NUM_BYTES [expr [dict get $ports TDATA] / 8]]
            }

            if {[dict exists $ports TDEST]} {
                lappend bus_parameters [list TDEST_WIDTH [dict get $ports TDEST]]
            }

            if {[dict exists $ports TID]} {
                lappend bus_parameters [list TID_WIDTH [dict get $ports TID]]
            }

            if {[dict exists $ports TUSER]} {
                lappend bus_parameters [list TUSER_WIDTH [dict get $ports TUSER]]
            } else {
                lappend bus_parameters [list TUSER_WIDTH 0]
            }

            set layered_metadata ""
            if {$SupportDataType && [dict exists $ctype TDATA]} {
                set ::__warn_sub_field__ 0
                dict set layered_metadata $iptypes::vlnv TDATA [create_datatype [dict get $ctype TDATA]]
                if {$::__warn_sub_field__} {
                    puts "TDATA of AXI4-Stream interface '$interface_name' contains sub-fields not aligned to byte boundaries. The resulting layout may not be compatible with the connecting interface."
                }
                if {[dict exists $ctype TDATA Name]} {
                    dict set layered_metadata $iptypes::vlnv TDATA datatype name value [dict get $ctype TDATA Name]
                }
            }
            if {$SupportDataType && [dict exists $ctype TUSER]} {
                set ::__warn_sub_field__ 0
                dict set layered_metadata $iptypes::vlnv TUSER [create_datatype [dict get $ctype TUSER]]
                if {$::__warn_sub_field__} {
                    puts "TUSER of AXI4-Stream interface '$interface_name' contains sub-fields not aligned to byte boundaries. The resulting layout may not be compatible with the connecting interface."
                }
            }
            lappend bus_parameters [list LAYERED_METADATA $layered_metadata generated]

            # tvalid
            add_port $core ${port_prefix}_TVALID $dir0 "" ""

            # tready
            if {$has_tready} {
                add_port $core ${port_prefix}_TREADY $dir1 "" ""
            }

            # other ports
            set tieoff {TUSER 0 TDEST 0 TID 0 TLAST 0 TKEEP 1 TSTRB 1}
            set port_names [dict keys $ports]
            foreach port_name $port_names {
                set port_width [dict get $ports $port_name]
                if {$dir0 == "in" && [dict exists $tieoff $port_name]} {
                    set driver_value [expr [dict get $tieoff $port_name] * (2 ** $port_width - 1)]
                    add_port $core ${port_prefix}_${port_name} $dir0 $port_width "" endianness little driver_value $driver_value
                } else {
                    add_port $core ${port_prefix}_${port_name} $dir0 $port_width "" endianness little
                }
            }

            ## create bus interface
            set current_bus_interface [add_bus_interface $core $interface_name axi4stream $mode]

            ## port map
            # tvalid
            add_port_map $current_bus_interface "TVALID" "TVALID" ${port_prefix}_TVALID

            # tready
            if {$has_tready} {
                add_port_map $current_bus_interface "TREADY" "TREADY" ${port_prefix}_TREADY
            }

            # other ports
            dict for {port_name port_width} $ports {
                add_port_map $current_bus_interface $port_name $port_name ${port_prefix}_${port_name}
            }

            ## bus parameters
            foreach bus_parameter $bus_parameters {
                lassign $bus_parameter pname pvalue presolve_type
                add_bus_parameter $current_bus_interface $pname $pvalue $presolve_type
            }

            # }}}
        }

        native_axim {
            # {{{
            ## direction
            if {$mode == "master"} {
                set dir0 "out"
                set dir1 "in"
            } else {
                set dir0 "in"
                set dir1 "out"
            }

            ## address width
            if {$mode == "master"} {
                set addr_bits [dict get $port_width AWADDR]
                set wstrb_bits [dict get $port_width WSTRB]
            }

            ## rtl ports
            set rtl_ports [list \
                [list AWID    $dir0 1  "${param_prefix}_ID_WIDTH" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_ID_PORTS')) = 1)" \
                ] \
                [list AWADDR  $dir0 $addr_bits "${param_prefix}_ADDR_WIDTH"] \
                [list AWLEN   $dir0 8  ""] \
                [list AWSIZE  $dir0 3  ""] \
                [list AWBURST $dir0 2  ""] \
                [list AWLOCK  $dir0 2  ""] \
                [list AWREGION $dir0 4  ""] \
                [list AWCACHE $dir0 4  ""] \
                [list AWPROT  $dir0 3  ""] \
                [list AWQOS   $dir0 4  ""] \
                [list AWUSER  $dir0 1  "${param_prefix}_AWUSER_WIDTH" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                ] \
                [list AWVALID $dir0 "" ""] \
                [list AWREADY $dir1 "" ""] \
                [list WID     $dir0 1  "${param_prefix}_ID_WIDTH" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_ID_PORTS')) = 1)" \
                ] \
                [list WDATA   $dir0 $data_width "${param_prefix}_DATA_WIDTH"] \
                [list WSTRB   $dir0 $wstrb_bits  "${param_prefix}_DATA_WIDTH/8"] \
                [list WLAST   $dir0 "" ""] \
                [list WUSER   $dir0 1  "${param_prefix}_WUSER_WIDTH" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                ] \
                [list WVALID  $dir0 "" ""] \
                [list WREADY  $dir1 "" ""] \
                [list BID     $dir1 1  "${param_prefix}_ID_WIDTH" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_ID_PORTS')) = 1)" \
                ] \
                [list BRESP   $dir1 2  ""] \
                [list BUSER   $dir1 1  "${param_prefix}_BUSER_WIDTH" \
                    driver_value {0} \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                ] \
                [list BVALID  $dir1 "" ""] \
                [list BREADY  $dir0 "" ""] \
                [list ARID    $dir0 1  "${param_prefix}_ID_WIDTH" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_ID_PORTS')) = 1)" \
                ] \
                [list ARADDR  $dir0 $addr_bits "${param_prefix}_ADDR_WIDTH"] \
                [list ARLEN   $dir0 8  ""] \
                [list ARSIZE  $dir0 3  ""] \
                [list ARBURST $dir0 2  ""] \
                [list ARLOCK  $dir0 2  ""] \
                [list ARREGION $dir0 4  ""] \
                [list ARCACHE $dir0 4  ""] \
                [list ARPROT  $dir0 3  ""] \
                [list ARQOS   $dir0 4  ""] \
                [list ARUSER  $dir0 1  "${param_prefix}_ARUSER_WIDTH" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                ] \
                [list ARVALID $dir0 "" ""] \
                [list ARREADY $dir1 "" ""] \
                [list RID     $dir1 1  "${param_prefix}_ID_WIDTH" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_ID_PORTS')) = 1)" \
                ] \
                [list RDATA   $dir1 $data_width "${param_prefix}_DATA_WIDTH"] \
                [list RRESP   $dir1 2  ""] \
                [list RLAST   $dir1 "" ""] \
                [list RUSER   $dir1 1  "${param_prefix}_RUSER_WIDTH" \
                    driver_value {0} \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                ] \
                [list RVALID  $dir1 "" ""] \
                [list RREADY  $dir0 "" ""] \
            ]

            ## rtl parameters
            set rtl_parameters [list \
                [list ID_WIDTH "integer" 1  "long" "generated" \
                    enablement_presence optional \
                    enablement_resolve_type dependent \
                ] \
                [list ADDR_WIDTH   "integer" $addr_bits "long" "immediate"] \
                [list DATA_WIDTH   "integer" $data_width "long" "generated"] \
                [list AWUSER_WIDTH "integer" 1  "long" "generated" \
                    enablement_presence optional \
                    enablement_resolve_type dependent \
                ] \
                [list ARUSER_WIDTH "integer" 1  "long" "generated" \
                    enablement_presence optional \
                    enablement_resolve_type dependent \
                ] \
                [list WUSER_WIDTH  "integer" 1  "long" "generated" \
                    enablement_presence optional \
                    enablement_resolve_type dependent \
                ] \
                [list RUSER_WIDTH  "integer" 1  "long" "generated" \
                    enablement_presence optional \
                    enablement_resolve_type dependent \
                ] \
                [list BUSER_WIDTH  "integer" 1  "long" "generated" \
                    enablement_presence optional \
                    enablement_resolve_type dependent \
                ] \
                [list USER_VALUE      "$user_param_type" 0x00000000   "bitString" "generated" \
                    value_bit_string_length 32 \
                    enablement_presence optional \
                    enablement_resolve_type dependent \
                ] \
                [list PROT_VALUE      "$user_param_type" \"000\"  "bitString" "generated" \
                    value_bit_string_length 3 \
                ] \
                [list CACHE_VALUE     "$user_param_type" \"0011\" "bitString" "generated" \
                    value_bit_string_length 4 \
                ] \
            ]

            ## user parameters
            set user_parameters [list \
                [list ENABLE_ID_PORTS "Enable ID ports" "false" "bool" "user"] \
                [list ID_WIDTH "ID width" 1 "long" "user" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_ID_PORTS')) = 1)" \
                    value_validation_range_maximum 32 \
                    value_validation_range_minimum 1 \
                ] \
                [list DATA_WIDTH "Data width" $data_width "long" "user" \
                    value_validation_list {32:32 64:64 128:128 256:256 512:512 1024:1024} \
                ] \
                [list ENABLE_USER_PORTS "Enable USER ports" "false" "bool" "user"] \
                [list AWUSER_WIDTH "AWUSER width" 1 "long" "user" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                    value_validation_range_maximum 1024 \
                    value_validation_range_minimum 1 \
                ] \
                [list WUSER_WIDTH "WUSER width" 1 "long" "user" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                    value_validation_range_maximum 1024 \
                    value_validation_range_minimum 1 \
                ] \
                [list BUSER_WIDTH "BUSER width" 1 "long" "user" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                    value_validation_range_maximum 1024 \
                    value_validation_range_minimum 1 \
                ] \
                [list ARUSER_WIDTH "ARUSER width" 1 "long" "user" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                    value_validation_range_maximum 1024 \
                    value_validation_range_minimum 1 \
                ] \
                [list RUSER_WIDTH "RUSER width" 1 "long" "user" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                    value_validation_range_maximum 1024 \
                    value_validation_range_minimum 1 \
                ] \
                [list USER_VALUE "USER value" 0x00000000 "bitString" "user" \
                    enablement_presence optional \
                    enablement_dependency "(spirit:decode(id('PARAM_VALUE.${param_prefix}_ENABLE_USER_PORTS')) = 1)" \
                    value_bit_string_length 32 \
                ] \
                [list PROT_VALUE "PROT value" \"000\" "bitString" "user" \
                    value_bit_string_length 3 \
                ] \
                [list CACHE_VALUE "CACHE value" \"0011\" "bitString" "user" \
                    value_bit_string_length 4 \
                ] \
            ]

           if {$HasOffset==0} {
               lappend rtl_parameters [list TARGET_ADDR  "$user_param_type" 0x00000000 "bitString" "generated" value_bit_string_length 32]
               lappend user_parameters [list TARGET_ADDR "Base address of target slave" 0x00000000 "bitString" "user" value_bit_string_length 32]
           }

            set bus_parameters [list \
                [list ADDR_WIDTH $addr_bits] \
                [list MAX_BURST_LENGTH 256] \
                [list NUM_READ_OUTSTANDING $NUM_READ_OUTSTANDING] \
                [list NUM_WRITE_OUTSTANDING $NUM_WRITE_OUTSTANDING] \
                [list MAX_READ_BURST_LENGTH $MAX_READ_BURST_LENGTH] \
                [list MAX_WRITE_BURST_LENGTH $MAX_WRITE_BURST_LENGTH] \
                [list PROTOCOL AXI4] \
                [list READ_WRITE_MODE READ_WRITE] \
                [list HAS_BURST 0] \
                [list SUPPORTS_NARROW_BURST 0] \
            ]

            ## axi4
            set current_bus_interface [add_bus_interface $core $interface_name axi4 $mode $preferred_usage_value $has_dependant_on $offset_slave_name $addr_bits]

            ## rtl parameters
            foreach rtl_parameter $rtl_parameters {
                set pargs [lassign $rtl_parameter pname ptype pvalue pformat presolve_type]
                eval add_hdl_parameter \$core \${param_prefix}_\$pname \$ptype \$pvalue \$pformat \$presolve_type $pargs
            }

            ## user parameters
            foreach user_parameter $user_parameters {
                set pargs [lassign $user_parameter pname pdisplay_name pvalue pformat presolve_type]
                eval add_user_parameter \$core \${param_prefix}_\$pname \$pdisplay_name \$pvalue \$pformat \$presolve_type $pargs config_groups \[list 1 \"\$interface_name (AXI4 Master Interface)\"\]
            }

            ## bus parameters
            foreach bus_parameter $bus_parameters {
                lassign $bus_parameter pname pvalue
                add_bus_parameter $current_bus_interface $pname $pvalue
            }

            ## ports
            foreach rtl_port $rtl_ports {
                set port_args [lassign $rtl_port port_name port_dir port_width port_param]
                eval add_port \$core \${port_prefix}_\$port_name \$port_dir \$port_width \$port_param $port_args
            }

            # port map
            foreach rtl_port $rtl_ports {
                set port_name [lindex $rtl_port 0]
                add_port_map $current_bus_interface $port_name $port_name ${port_prefix}_${port_name}
            }
            # }}}
        }

        bram {
            # {{{

            ## rtl ports
            set rtl_ports [list \
                [list Clk  CLK  out "" ""] \
                [list Rst  RST  out "" ""] \
                [list EN   EN   out "" ""] \
                [list WEN  WE   out [expr $mem_width / 8] ""] \
                [list Addr ADDR out 32 ""] \
                [list Dout DIN  out $mem_width ""] \
                [list Din  DOUT in  $mem_width ""] \
            ]

            ## bus parameters
            set bus_parameters [list \
                [list MEM_WIDTH $mem_width] \
                [list MEM_SIZE [expr $mem_width * $mem_depth / 8]] \
                [list MASTER_TYPE $master_type] \
            ]

            foreach mem_port $mem_ports {
                set suffix [string toupper $mem_port]
                ## interface
                set current_bus_interface [add_bus_interface $core ${interface_name}_PORT$suffix bram master]

                ## ports
                foreach rtl_port $rtl_ports {
                    lassign $rtl_port port_name port_map port_dir port_width port_param
                    add_port $core ${port_prefix}_${port_name}_$suffix $port_dir $port_width $port_param
                }

                ## bus parameters
                foreach bus_parameter $bus_parameters {
                    lassign $bus_parameter pname pvalue
                    add_bus_parameter $current_bus_interface $pname $pvalue
                }

                # port map
                foreach rtl_port $rtl_ports {
                    lassign $rtl_port port_name port_map
                    add_port_map $current_bus_interface $port_map $port_map ${port_prefix}_${port_name}_$suffix
                }
            }
            # }}}
        }

        native_bram {
            # {{{

            ## rtl ports
            set rtl_ports [list \
                [list Clk  CLK  out "" ""] \
                [list Rst  RST  out "" ""] \
                [list EN   EN   out "" ""] \
                [list WEN  WE   out $we_width ""] \
                [list Addr ADDR out $addr_width ""] \
                [list Din  DIN  out $mem_width ""] \
                [list Dout DOUT in  $mem_width ""] \
            ]

            ## bus parameters
            set bus_parameters [list \
                [list MEM_WIDTH $mem_width] \
                [list MEM_SIZE [expr $mem_width * $mem_depth / 8]] \
                [list MASTER_TYPE $master_type] \
            ]

            foreach mem_port $mem_ports {
                set suffix [string toupper $mem_port]
                ## interface
                set current_bus_interface [add_bus_interface $core ${interface_name}_PORT$suffix bram master]

                ## ports
                foreach rtl_port $rtl_ports {
                    lassign $rtl_port port_name port_map port_dir port_width port_param
                    add_port $core ${port_prefix}_${port_name}_$suffix $port_dir $port_width $port_param
                }

                ## bus parameters
                foreach bus_parameter $bus_parameters {
                    lassign $bus_parameter pname pvalue
                    add_bus_parameter $current_bus_interface $pname $pvalue
                }

                # port map
                foreach rtl_port $rtl_ports {
                    lassign $rtl_port port_name port_map
                    add_port_map $current_bus_interface $port_map $port_map ${port_prefix}_${port_name}_$suffix
                }

                # data type
                add_bus_datatype $current_bus_interface $ctype
            }
            # }}}
        }

        ap_fifo {
            # {{{
            if {$fifo_type == "read"} {
                set interface_type fifo_read
                set rtl_ports [list \
                    [list ${interface_name}_dout    RD_DATA in  $fifo_width] \
                    [list ${interface_name}_empty_n EMPTY_N in  ""] \
                    [list ${interface_name}_read    RD_EN   out ""] \
                ]
            } else {
                set interface_type fifo_write
                set rtl_ports [list \
                    [list ${interface_name}_din     WR_DATA out $fifo_width] \
                    [list ${interface_name}_full_n  FULL_N  in  ""] \
                    [list ${interface_name}_write   WR_EN   out ""] \
                ]
            }

            ## interface
            set current_bus_interface [add_bus_interface $core $interface_name $interface_type master]

            ## ports
            foreach rtl_port $rtl_ports {
                lassign $rtl_port port_name port_map port_dir port_width
                add_port $core $port_name $port_dir $port_width ""
            }

            # port map
            foreach rtl_port $rtl_ports {
                lassign $rtl_port port_name port_map
                add_port_map $current_bus_interface $port_map $port_map $port_name
            }

            # data type
            add_bus_datatype $current_bus_interface $ctype
            # }}}
        }

        ap_ctrl {
            # {{{
            set rtl_ports ""
            foreach port $ctrl_ports {
                switch -- $port {
                    ap_start {
                        lappend rtl_ports [list ap_start start in ""]
                    }
                    ap_ready {
                        lappend rtl_ports [list ap_ready ready out ""]
                    }
                    ap_done {
                        lappend rtl_ports [list ap_done done out ""]
                    }
                    ap_continue {
                        lappend rtl_ports [list ap_continue continue in ""]
                    }
                    ap_idle {
                        lappend rtl_ports [list ap_idle idle out ""]
                    }
                }
            }

            ## interface
            set current_bus_interface [add_bus_interface $core $interface_name ap_ctrl slave]

            ## ports
            foreach rtl_port $rtl_ports {
                lassign $rtl_port port_name port_map port_dir port_width
                add_port $core $port_name $port_dir $port_width ""
            }

            # port map
            foreach rtl_port $rtl_ports {
                lassign $rtl_port port_name port_map
                add_port_map $current_bus_interface $port_map $port_map $port_name
            }

            # data type
            add_bus_datatype $current_bus_interface $ctype
            # }}}
        }

        clock {
            # {{{
            add_port $core $interface_name in "" ""
            set current_bus_interface [add_bus_interface $core $interface_name clock slave]
            add_port_map $current_bus_interface CLK CLK $interface_name

            if {$buses != ""} {
                add_bus_parameter $current_bus_interface ASSOCIATED_BUSIF [join $buses ":"]
            }

            # attach reset
            if {[info exists reset] && $reset != ""} {
                add_bus_parameter $current_bus_interface ASSOCIATED_RESET [join $reset ":"]
            }

            # attach ce
            set result [dict filter $Interfaces script {name detail} {
                string equal [dict get $detail type] clockenable
            }]
            set port [lindex [dict keys $result] 0]
            if {$port != ""} {
                add_bus_parameter $current_bus_interface ASSOCIATED_CLKEN $port
            }

            # data type
            add_bus_datatype $current_bus_interface $ctype
            # }}}
        }

        reset {
            # {{{
            add_port $core $interface_name in "" ""
            set current_bus_interface [add_bus_interface $core $interface_name reset slave]
            add_port_map $current_bus_interface RST RST $interface_name
            if { ![info exists polarity] } { set polarity ACTIVE_LOW }
            add_bus_parameter $current_bus_interface POLARITY $polarity

            # data type
            add_bus_datatype $current_bus_interface $ctype
            # }}}
        }

        clockenable {
            # {{{
            add_port $core $interface_name in "" ""
            set current_bus_interface [add_bus_interface $core $interface_name clockenable slave]
            add_port_map $current_bus_interface CE CE $interface_name

            # data type
            add_bus_datatype $current_bus_interface $ctype
            # }}}
        }

        interrupt {
            # {{{
            add_port $core $interface_name out "" ""
            set current_bus_interface [add_bus_interface $core $interface_name interrupt master]
            add_port_map $current_bus_interface Intr INTERRUPT $interface_name
            add_bus_parameter $current_bus_interface SENSITIVITY "LEVEL_HIGH"

            # data type
            add_bus_datatype $current_bus_interface $ctype
            # }}}
        }

        data {
            # {{{
            if {$dir == "out"} {
                set mode "master"
            } else {
                set mode "slave"
            }
            add_port $core $interface_name $dir $width ""
            set current_bus_interface [add_bus_interface $core $interface_name $type $mode]
            add_port_map $current_bus_interface DATA DATA $interface_name

            # data type
            add_bus_datatype $current_bus_interface $ctype 1
            # }}}
        }
    }
}

## GUI
if {![regexp -nocase {2014\.3.*} $vivado_ver match]} {
    ipgui::add_group -name "group 0" -component [ipx::current_core] -parent [ipgui::get_pagespec -name "Page 0" -component [ipx::current_core] ] -display_name {m axi dev reg (AXI4 Master Interface)}
    set user_parameters_list [ipx::get_user_parameters -of_objects [ ipx::current_core ]]
    foreach {user_param} $user_parameters_list {
        set user_param_name [get_property name $user_param]
        if {[string compare -nocase $user_param_name "Component_Name"]} {
            ipgui::add_param -name $user_param_name -component [ipx::current_core] -parent [ipgui::get_groupspec -name "group 0" -component [ipx::current_core] ]
        }
    }
}
ipx::create_xgui_files -logo_file misc/logo.png $core

## System Info
set user_parameters_list {clk_period 10 machine 64 combinational 0 latency 2447789 II x}
foreach {user_para value} $user_parameters_list {
    incr user_parameter_order
    set user_para_value [ipx::add_user_parameter $user_para $core]
    set_property value $value $user_para_value
    set_property value_resolve_type "immediate" $user_para_value
    set_property order $user_parameter_order $user_para_value
}


ipx::update_checksums $core
ipx::save_core $core

## Generate zip
set ZipFile [string map {. _} ${Vendor}_${Library}_${IPName}_${Version}].zip
ipx::archive_core [file join [pwd] $ZipFile] $core

## Generate XO file if kernel.xml file is dumped
if {$enable_xo_gen && $kernel_xo ne ""} {
    set kernel_xml [file join $sdaccel_dir kernel.xml]
    if {[file isfile $kernel_xml]} {
        set ip_unzip_dir [file join [pwd] ip_unzip_dir]
        catch {exec unzip -d $ip_unzip_dir $ZipFile}
        set design_xml [file join $solution_dir .autopilot db ${TopNoPrefix}.design.xml]
        if { [file exists $kernel_xo] } {
            file delete -force $kernel_xo
        }
        if { ![file exists [file dir $kernel_xo]] } {
            file mkdir [file dir $kernel_xo]
        }
        set pack_xo_args [list -xo_path $kernel_xo -kernel_name $sdx_kernel_name -kernel_xml $kernel_xml]
        if {[llength $sdx_kernel_files]} {
            lappend pack_xo_args -kernel_files $sdx_kernel_files
        }
        if {[file isdirectory $ip_unzip_dir]} {
            lappend pack_xo_args -ip_directory $ip_unzip_dir
        } else {
            lappend pack_xo_args -ip_directory [pwd]
        }
        if {[file isfile $design_xml]} {
            lappend pack_xo_args -design_xml $design_xml
        } else { puts "No design.xml file found: $design_xml"
        }
        if {[file isdirectory $debug_dir] && [llength [glob -nocomplain $debug_dir/*]]} {
            lappend pack_xo_args -debug_directory $debug_dir
        }
        if {[file isdirectory $xo_hls_files_dir] && [regsub {(\.[0-9][0-9]*)\.[0-9].*$} [::version -short] {\1}] > 2018.2} {
            lappend pack_xo_args -hls_directory $xo_hls_files_dir
        }
        puts "Running package_xo $pack_xo_args"
        package_xo {*}$pack_xo_args
        if {[file isdirectory $ip_unzip_dir]} {
            file delete -force $ip_unzip_dir
        }
    } else { 
        puts "Not running package_xo, missing kernel.xml: $kernel_xml"
    }
}

